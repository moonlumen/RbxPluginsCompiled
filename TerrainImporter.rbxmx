<roblox version="4">
  <Item class="Folder" referent="0">
    <Properties>
      <string name="Name">ImportTerrain</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">Modules</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">CollapsibleTitledSection</string>
          <string name="Source">----------------------------------------
--
-- CollapsibleTitledSectionClass
--
-- Creates a section with a title label:
--
-- "SectionXXX"
--     "TitleBarVisual"
--     "Contents"
--
-- Requires "parent" and "sectionName" parameters and returns the section and its contentsFrame
-- The entire frame will resize dynamically as contents frame changes size.
--
--  "showTitle" is true by default and will not display the section title if false
-- Both "minimizeable" and "minimizedByDefault" are false by default
-- These parameters define if the section will have an arrow button infront of the title label, 
-- which the user may use to hide the section's contents
--
----------------------------------------
GuiUtilities = require(script.Parent.GuiUtilities)

local kRightButtonAsset = "rbxasset://textures/TerrainTools/button_arrow.png"
local kDownButtonAsset = "rbxasset://textures/TerrainTools/button_arrow_down.png"

local kArrowSize = 9
local kDoubleClickTimeSec = 0.5

CollapsibleTitledSectionClass = {}
CollapsibleTitledSectionClass.__index = CollapsibleTitledSectionClass


function CollapsibleTitledSectionClass.new(nameSuffix, titleText, showTitle, minimizable, minimizedByDefault)
	local self = {}
	setmetatable(self, CollapsibleTitledSectionClass)

	showTitle = showTitle or showTitle == nil
	
	self._minimized = minimizedByDefault
	self._minimizable = minimizable

	self._titleBarHeight = showTitle and GuiUtilities.kTitleBarHeight or 0

	local frame = Instance.new('Frame')
	frame.Name = 'CTSection' .. nameSuffix
	frame.BackgroundTransparency = 1
	self._frame = frame

	local uiListLayout = Instance.new('UIListLayout')
	uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	uiListLayout.Parent = frame
	self._uiListLayout = uiListLayout

	local contentsFrame = Instance.new('Frame')
	contentsFrame.Name = 'Contents'
	contentsFrame.BackgroundTransparency = 1
	contentsFrame.Size = UDim2.new(1, 0, 0, 1)
	contentsFrame.Position = UDim2.new(0, 0, 0, titleBarSize)
	contentsFrame.Parent = frame
	contentsFrame.LayoutOrder = 2
	GuiUtilities.syncGuiElementBackgroundColor(contentsFrame)

	self._contentsFrame = contentsFrame

	uiListLayout:GetPropertyChangedSignal('AbsoluteContentSize'):connect(function()
		self:_UpdateSize()
	end)
	self:_UpdateSize()

	if showTitle then
		self:_CreateTitleBar(titleText)
	end

	return self
end


function CollapsibleTitledSectionClass:GetSectionFrame()
	return self._frame
end

function CollapsibleTitledSectionClass:GetContentsFrame()
	return self._contentsFrame
end

function CollapsibleTitledSectionClass:_UpdateSize()
	local totalSize = self._uiListLayout.AbsoluteContentSize.Y
	if self._minimized then
		totalSize = self._titleBarHeight
	end
	self._frame.Size = UDim2.new(1, 0, 0, totalSize)
end

function CollapsibleTitledSectionClass:_UpdateMinimizeButton()
	-- We can't rotate it because rotated images don't get clipped by parents.
	-- This is all in a scroll widget.
	-- :(
	if (self._minimized) then 
		self._minimizeButton.Image = kRightButtonAsset
	else
		self._minimizeButton.Image = kDownButtonAsset
	end
end

function CollapsibleTitledSectionClass:_ToggleCollapsedState()
	self._minimized = not self._minimized
	self._contentsFrame.Visible = not self._minimized
	self:_UpdateMinimizeButton()
	self:_UpdateSize()
end

function CollapsibleTitledSectionClass:_CreateTitleBar(titleText)
	local titleTextOffset = self._titleBarHeight

	local titleBar = Instance.new('ImageButton')
	titleBar.AutoButtonColor = false
	titleBar.Name = 'TitleBarVisual'
	titleBar.BorderSizePixel = 0
	titleBar.Position = UDim2.new(0, 0, 0, 0)
	titleBar.Size = UDim2.new(1, 0, 0, self._titleBarHeight)
	titleBar.Parent = self._frame
	titleBar.LayoutOrder = 1
	GuiUtilities.syncGuiElementTitleColor(titleBar)

	local titleLabel = Instance.new('TextLabel')
	titleLabel.Name = 'TitleLabel'
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = Enum.Font.SourceSansBold                --todo: input spec font
	titleLabel.TextSize = 15                                  --todo: input spec font size
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Text = titleText
	titleLabel.Position = UDim2.new(0, titleTextOffset, 0, 0)
	titleLabel.Size = UDim2.new(1, -titleTextOffset, 1, GuiUtilities.kTextVerticalFudge)
	titleLabel.Parent = titleBar
	GuiUtilities.syncGuiElementFontColor(titleLabel)

	if self._minimizable then
		self._minimizeButton = Instance.new('ImageButton')
		self._minimizeButton.Name = 'MinimizeSectionButton'
		self._minimizeButton.Image = kRightButtonAsset              --todo: input arrow image from spec
		self._minimizeButton.Size = UDim2.new(0, kArrowSize, 0, kArrowSize)
		self._minimizeButton.AnchorPoint = Vector2.new(0.5, 0.5)
		self._minimizeButton.Position = UDim2.new(0, self._titleBarHeight*.5,
			 0, self._titleBarHeight*.5)
		self._minimizeButton.BackgroundTransparency = 1

		self._minimizeButton.MouseButton1Down:connect(function()
			self:_ToggleCollapsedState()
		end)
		self:_UpdateMinimizeButton()
		self._minimizeButton.Parent = titleBar
	end

	self._latestClickTime = 0
	titleBar.MouseButton1Down:connect(function()
		local now = tick()	
		if (now - self._latestClickTime &lt; kDoubleClickTimeSec) then 
			self:_ToggleCollapsedState()
			self._latestClickTime = 0
		else
			self._latestClickTime = now
		end
	end)
end

return CollapsibleTitledSectionClass</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">CustomTextButton</string>
          <string name="Source">----------------------------------------
--
-- CustomTextButton.lua
--
-- Creates text button with custom look &amp; feel, hover/click effects.
--
----------------------------------------
GuiUtilities = require(script.Parent.GuiUtilities)

local kButtonImageIdDefault = "rbxasset://textures/TerrainTools/button_default.png"
local kButtonImageIdHovered = "rbxasset://textures/TerrainTools/button_hover.png"
local kButtonImageIdPressed = "rbxasset://textures/TerrainTools/button_pressed.png"

CustomTextButtonClass = {}
CustomTextButtonClass.__index = CustomTextButtonClass

function CustomTextButtonClass.new(buttonName, labelText)
	local self = {}
	setmetatable(self, CustomTextButtonClass)

	local button = Instance.new('ImageButton')
	button.Name = buttonName
	button.Image = kButtonImageIdDefault
	button.BackgroundTransparency = 1
	button.ScaleType = Enum.ScaleType.Slice
	button.SliceCenter = Rect.new(7, 7, 156, 36)
	button.AutoButtonColor = false

	local label = Instance.new('TextLabel')
	label.Text = labelText
	label.BackgroundTransparency = 1
	label.Size = UDim2.new(1, 0, 1, GuiUtilities.kButtonVerticalFudge)
	label.Font = Enum.Font.SourceSans                  
	label.TextSize = 15                           
	label.Parent = button

	self._label = label
	self._button = button

	self._clicked = false
	self._hovered = false

	button.InputBegan:connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseMovement) then               
			self._hovered = true
			self:_updateButtonVisual()
		end
	end)


	button.InputEnded:connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseMovement) then               
			self._hovered = false
			self._clicked = false
			self:_updateButtonVisual()
		end
	end)    

	button.MouseButton1Down:connect(function()
		self._clicked = true
		self:_updateButtonVisual()
	end)

	button.MouseButton1Up:connect(function()
		self._clicked = false
		self:_updateButtonVisual()
	end)
	
	self:_updateButtonVisual()

	return self
end

function CustomTextButtonClass:_updateButtonVisual()
	if (self._clicked) then 
		self._button.Image = kButtonImageIdPressed
		self._label.TextColor3 = GuiUtilities.kPressedButtonTextColor
	elseif (self._hovered) then 
		self._button.Image = kButtonImageIdHovered
		self._label.TextColor3 = GuiUtilities.kStandardButtonTextColor
	else
		self._button.Image = kButtonImageIdDefault
		self._label.TextColor3 = GuiUtilities.kStandardButtonTextColor
	end
end

function CustomTextButtonClass:getButton()
	return self._button
end

return CustomTextButtonClass</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">GuiUtilities</string>
          <string name="Source">local module = {}


module.kTitleBarHeight = 27
module.kInlineTitleBarHeight = 24

module.kStandardContentAreaWidth = 180

module.kStandardPropertyHeight = 30
module.kSubSectionLabelHeight = 30

module.kStandardVMargin = 7
module.kStandardHMargin = 16

module.kCheckboxMinLabelWidth = 52
module.kCheckboxMinMargin = 12
module.kCheckboxWidth = 12

module.kRadioButtonsHPadding = 24

module.StandardLineLabelLeftMargin = module.kTitleBarHeight
module.StandardLineElementLeftMargin = (module.StandardLineLabelLeftMargin + module.kCheckboxMinLabelWidth
+ module.kCheckboxMinMargin + module.kCheckboxWidth + module.kRadioButtonsHPadding)
module.StandardLineLabelWidth = (module.StandardLineElementLeftMargin - module.StandardLineLabelLeftMargin - 10 )

module.kDropDownHeight = 55

module.kBottomButtonsFrameHeight = 50
module.kBottomButtonsHeight = 28

module.kShapeButtonSize = 32
module.kTextVerticalFudge = -3
module.kButtonVerticalFudge = -5

module.kBottomButtonsWidth = 100

module.kDisabledTextColor = Color3.new(.4, .4, .4)                   --todo: input spec disabled text color
module.kStandardButtonTextColor = Color3.new(0, 0, 0)                --todo: input spec disabled text color
module.kPressedButtonTextColor = Color3.new(1, 1, 1)                 --todo: input spec disabled text color

module.kButtonStandardBackgroundColor = Color3.new(1, 1, 1)          --todo: sync with spec
module.kButtonStandardBorderColor = Color3.new(.4,.4,.4)             --todo: sync with spec
module.kButtonDisabledBackgroundColor = Color3.new(.7,.7,.7)         --todo: sync with spec
module.kButtonDisabledBorderColor = Color3.new(.6,.6,.6)             --todo: sync with spec

module.kButtonBackgroundTransparency = 0.5
module.kButtonBackgroundIntenseTransparency = 0.4

module.kMainFrame = nil

function module.ShouldUseIconsForDarkerBackgrounds()
	local mainColor = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.MainBackground)
	return (mainColor.r + mainColor.g + mainColor.b) / 3 &lt; 0.5
end

function module.SetMainFrame(frame)
	module.kMainFrame = frame
end

function module.syncGuiElementTitleColor(guiElement)
	local function setColors()
		guiElement.BackgroundColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.Titlebar)
	end
	settings().Studio.ThemeChanged:connect(setColors)
	setColors()
end

function module.syncGuiElementInputFieldColor(guiElement)
	local function setColors()
		guiElement.BackgroundColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.InputFieldBackground)
	end
	settings().Studio.ThemeChanged:connect(setColors)
	setColors()
end

function module.syncGuiElementBackgroundColor(guiElement)
	local function setColors()
		guiElement.BackgroundColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.MainBackground)
	end
	settings().Studio.ThemeChanged:connect(setColors)
	setColors()
end

function module.syncGuiElementStripeColor(guiElement)
	local function setColors()
		if ((guiElement.LayoutOrder + 1) % 2 == 0) then 
			guiElement.BackgroundColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.MainBackground)
		else
			guiElement.BackgroundColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.CategoryItem)
		end
	end
	settings().Studio.ThemeChanged:connect(setColors)
	setColors()
end

function module.syncGuiElementBorderColor(guiElement)
	local function setColors()
		guiElement.BorderColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.Border)
	end
	settings().Studio.ThemeChanged:connect(setColors)
	setColors()
end

function module.syncGuiElementFontColor(guiElement)
	local function setColors()
		guiElement.TextColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.MainText)
	end
	settings().Studio.ThemeChanged:connect(setColors)
	setColors()
end

-- A frame with standard styling.
function module.MakeFrame(name)
	local frame = Instance.new("Frame")
	frame.Name = name
	frame.BackgroundTransparency = 0
	frame.BorderSizePixel = 0

	module.syncGuiElementBackgroundColor(frame)

	return frame
end
	

-- A frame that is a whole line, containing some arbitrary sized widget.
function module.MakeFixedHeightFrame(name, height)
	local frame = module.MakeFrame(name)
	frame.Size = UDim2.new(1, 0, 0, height)

	return frame
end

-- A frame that is one standard-sized line, containing some standard-sized widget (label, edit box, dropdown, 
-- checkbox)
function module.MakeStandardFixedHeightFrame(name)
	return module.MakeFixedHeightFrame(name, module.kStandardPropertyHeight)
end

function module.AdjustHeightDynamicallyToLayout(frame, uiLayout, optPadding)
	if (not optPadding) then 
		optPadding = 0
	end

	local function updateSizes()
		frame.Size = UDim2.new(1, 0, 0, uiLayout.AbsoluteContentSize.Y + optPadding)
	end
	uiLayout:GetPropertyChangedSignal("AbsoluteContentSize"):connect(updateSizes)
	updateSizes()
end

-- Assumes input frame has a List layout with sort order layout order.
-- Add frames in order as siblings of list layout, they will be laid out in order.
-- Color frame background accordingly.
function module.AddStripedChildrenToListFrame(listFrame, frames)
	for index, frame in ipairs(frames) do 
		frame.Parent = listFrame
		frame.LayoutOrder = index
		frame.BackgroundTransparency = 0
		frame.BorderSizePixel = 1
		module.syncGuiElementStripeColor(frame)
		module.syncGuiElementBorderColor(frame)
	end
end

local function MakeSectionInternal(parentGui, name, title, contentHeight)
	local frame = Instance.new("Frame")
	frame.Name = name
	frame.BackgroundTransparency = 1
	frame.Parent = parentGui
	frame.BackgroundTransparency = 1
	frame.BorderSizePixel = 0
	
	-- If title is "nil', no title bar.
	local contentYOffset = 0
	local titleBar = nil
	if (title ~= nil) then  
		local titleBarFrame = Instance.new("Frame")
		titleBarFrame.Name = "TitleBarFrame"
		titleBarFrame.Parent = frame
		titleBarFrame.Position = UDim2.new(0, 0, 0, 0)
		titleBarFrame.LayoutOrder = 0

		local titleBar = Instance.new("TextLabel")
		titleBar.Name = "TitleBarLabel"
		titleBar.Text = title
		titleBar.Parent = titleBarFrame
		titleBar.BackgroundTransparency = 1
		titleBar.Position = UDim2.new(0, module.kStandardHMargin, 0, 0)

		module.syncGuiElementFontColor(titleBar)
	
		contentYOffset = contentYOffset + module.kTitleBarHeight
	end

	frame.Size = UDim2.new(1, 0, 0, contentYOffset + contentHeight)

	return frame
end

function module.MakeStandardPropertyLabel(text, opt_ignoreThemeUpdates)
	local label = Instance.new('TextLabel')
	label.Name = 'Label'
	label.BackgroundTransparency = 1
	label.Font = Enum.Font.SourceSans                    --todo: input spec font
	label.TextSize = 15                                  --todo: input spec font size
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Text = text
	label.AnchorPoint = Vector2.new(0, 0.5)
	label.Position = UDim2.new(0, module.StandardLineLabelLeftMargin, 0.5, module.kTextVerticalFudge)
	label.Size = UDim2.new(0, module.StandardLineLabelWidth, 1, 0)

	if (not opt_ignoreThemeUpdates) then 			
		module.syncGuiElementFontColor(label)
	end

	return label
end

function module.MakeFrameWithSubSectionLabel(name, text)
	local row = module.MakeFixedHeightFrame(name, module.kSubSectionLabelHeight)
	row.BackgroundTransparency = 1
		
	local label = module.MakeStandardPropertyLabel(text)
	label.BackgroundTransparency = 1
	label.Parent = row

	return row
end

function module.MakeFrameAutoScalingList(frame)
	local uiListLayout = Instance.new("UIListLayout")
	uiListLayout.Parent = frame
	uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder

	module.AdjustHeightDynamicallyToLayout(frame, uiListLayout)
end


return module</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">ImageButtonWithText</string>
          <string name="Source">----------------------------------------
--
-- ImageButtonWithText.lua
--
-- An image button with text underneath.  Standardized hover, clicked, and 
-- selected states.
--
----------------------------------------
GuiUtilities = require(script.Parent.GuiUtilities)

ImageButtonWithTextClass = {}
ImageButtonWithTextClass.__index = ImageButtonWithTextClass

local kSelectedBaseTransparency = 0.2
local kAdditionalTransparency = 0.1

function ImageButtonWithTextClass.new(name, 
		layoutOrder, 
		icon, 
		text, 
		buttonSize,
		imageSize, 
		imagePos, 
		textSize, 
		textPos)
	local self = {}
	setmetatable(self, ImageButtonWithTextClass)

	local button = Instance.new("ImageButton")
	button.Name = name
	button.AutoButtonColor = false
	button.Size = buttonSize
	button.BorderSizePixel = 1
	-- Image-with-text button has translucent background and "selected" background color.
	-- When selected we set transluency to not-zero so we see selected color.
	button.BackgroundTransparency = 1 

	button.LayoutOrder = layoutOrder

	local buttonIcon = Instance.new("ImageLabel")
	buttonIcon.BackgroundTransparency = 1
	buttonIcon.Image = icon or ""
	buttonIcon.Size = imageSize
	buttonIcon.Position = imagePos
	buttonIcon.Parent = button

	local textLabel = Instance.new("TextLabel")
	textLabel.BackgroundTransparency = 1
	textLabel.Text = text
	textLabel.Size = textSize
	textLabel.Position = textPos
	textLabel.TextScaled = true
	textLabel.Font = Enum.Font.SourceSans
	textLabel.Parent = button

	GuiUtilities.syncGuiElementFontColor(textLabel)

	local uiTextSizeConstraint = Instance.new("UITextSizeConstraint")
	-- Spec asks for fontsize of 12 pixels, but in Roblox the text font sizes look smaller than the mock
	--Note: For this font the Roblox text size is 25.7% larger than the design spec. 
	uiTextSizeConstraint.MaxTextSize = 15		                                          
	uiTextSizeConstraint.Parent = textLabel

	self._button = button
	self._clicked = false
	self._hovered = false
	self._selected = false

	button.InputBegan:connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseMovement) then               
			self._hovered = true
			self:_updateButtonVisual()
		end
	end)


	button.InputEnded:connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseMovement) then               
			self._hovered = false
			self._clicked = false
			self:_updateButtonVisual()
		end
	end)    

	button.MouseButton1Down:connect(function()
		self._clicked = true
		self:_updateButtonVisual()
	end)

	button.MouseButton1Up:connect(function()
		self._clicked = false
		self:_updateButtonVisual()
	end)
	
	function updateButtonVisual()
		self:_updateButtonVisual()
	end
	settings().Studio.ThemeChanged:connect(updateButtonVisual)

	self:_updateButtonVisual()

	return self
end

function ImageButtonWithTextClass:_updateButtonVisual()
	-- Possibilties:
	if (self._clicked) then 
		-- This covers 'clicked and selected' or 'clicked'
		self._button.BackgroundColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.Button, 
			Enum.StudioStyleGuideModifier.Selected)
		self._button.BorderColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.Border, 
			Enum.StudioStyleGuideModifier.Selected)
		if (self._selected) then 
			self._button.BackgroundTransparency = GuiUtilities.kButtonBackgroundIntenseTransparency
		else
			self._button.BackgroundTransparency = GuiUtilities.kButtonBackgroundTransparency
		end
	elseif (self._hovered) then 
		-- This covers 'hovered and selected' or 'hovered'
		self._button.BackgroundColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.Button, 
			Enum.StudioStyleGuideModifier.Hover)
		self._button.BorderColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.Border, 
			Enum.StudioStyleGuideModifier.Hover)
		if (self._selected) then 
			self._button.BackgroundTransparency = GuiUtilities.kButtonBackgroundIntenseTransparency
		else
			self._button.BackgroundTransparency = GuiUtilities.kButtonBackgroundTransparency
		end
	elseif (self._selected) then 
		-- This covers 'selected'
		self._button.BackgroundColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.Button, 
			Enum.StudioStyleGuideModifier.Selected)
		self._button.BorderColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.Border, 
			Enum.StudioStyleGuideModifier.Selected)
		self._button.BackgroundTransparency = GuiUtilities.kButtonBackgroundTransparency
	else
		-- This covers 'no special state'
		self._button.BackgroundColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.Button)
		self._button.BorderColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.Border)
		self._button.BackgroundTransparency = 1
	end
end

function ImageButtonWithTextClass:getButton()
	return self._button
end

function ImageButtonWithTextClass:setSelected(selected)
	self._selected = selected
	self:_updateButtonVisual()
end
 
function ImageButtonWithTextClass:getSelected()
	return self._selected
end


return ImageButtonWithTextClass</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">LabeledTextInput</string>
          <string name="Source"><![CDATA[----------------------------------------
--
-- LabeledTextInput.lua
--
-- Creates a frame containing a label and a text input control.
--
----------------------------------------
GuiUtilities = require(script.Parent.GuiUtilities)

local kTextInputWidth = 100
local kTextBoxInternalPadding = 4

LabeledTextInputClass = {}
LabeledTextInputClass.__index = LabeledTextInputClass

function LabeledTextInputClass.new(nameSuffix, labelText, defaultValue)
	local self = {}
	setmetatable(self, LabeledTextInputClass)

	-- Note: we are using "graphemes" instead of characters.
	-- In modern text-manipulation-fu, what with internationalization,
	-- emojis, etc, it's not enough to count characters, particularly when
	-- concerned with "how many <things> am I rendering?".
	self._MaxGraphemes = 10

	self._valueChangedFunction = nil

	local defaultValue = defaultValue or ""

	local frame = GuiUtilities.MakeStandardFixedHeightFrame('TextInput ' .. nameSuffix)
	self._frame = frame

	local label = GuiUtilities.MakeStandardPropertyLabel(labelText)
	label.Parent = frame
	self._label = label

	self._value = defaultValue

	-- Dumb hack to add padding to text box,
	local textBoxWrapperFrame = Instance.new("Frame")
	textBoxWrapperFrame.Name = "Wrapper"
	textBoxWrapperFrame.Size = UDim2.new(0, kTextInputWidth, 0.6, 0)
	textBoxWrapperFrame.Position = UDim2.new(0, GuiUtilities.StandardLineElementLeftMargin, .5, 0)
	textBoxWrapperFrame.AnchorPoint = Vector2.new(0, .5)
	textBoxWrapperFrame.Parent = frame
	GuiUtilities.syncGuiElementInputFieldColor(textBoxWrapperFrame)
	GuiUtilities.syncGuiElementBorderColor(textBoxWrapperFrame)

	local textBox = Instance.new("TextBox")
	textBox.Parent = textBoxWrapperFrame
	textBox.Name = "TextBox"
	textBox.Text = defaultValue
	textBox.Font = Enum.Font.SourceSans
	textBox.TextSize = 15
	textBox.BackgroundTransparency = 1
	textBox.TextXAlignment = Enum.TextXAlignment.Left
	textBox.Size = UDim2.new(1, -kTextBoxInternalPadding, 1, GuiUtilities.kTextVerticalFudge)
	textBox.Position = UDim2.new(0, kTextBoxInternalPadding, 0, 0)
	textBox.ClipsDescendants = true

	GuiUtilities.syncGuiElementFontColor(textBox)

	textBox:GetPropertyChangedSignal("Text"):connect(function()
		-- Never let the text be too long.
		-- Careful here: we want to measure number of graphemes, not characters,
		-- in the text, and we want to clamp on graphemes as well.
		if (utf8.len(self._textBox.Text) > self._MaxGraphemes) then
			local count = 0
			for start, stop in utf8.graphemes(self._textBox.Text) do
				count = count + 1
				if (count > self._MaxGraphemes) then
					-- We have gone one too far.
					-- clamp just before the beginning of this grapheme.
					self._textBox.Text = string.sub(self._textBox.Text, 1, start-1)
					break
				end
			end
			-- Don't continue with rest of function: the resetting of "Text" field
			-- above will trigger re-entry.  We don't need to trigger value
			-- changed function twice.
			return
		end

		self._value = self._textBox.Text
		if (self._valueChangedFunction) then
			self._valueChangedFunction(self._value)
		end
	end)

	self._textBox = textBox

	return self
end

function LabeledTextInputClass:SetValueChangedFunction(vcf)
	self._valueChangedFunction = vcf
end

function LabeledTextInputClass:GetTextBox()
	return self._textBox
end

function LabeledTextInputClass:GetFrame()
	return self._frame
end

function LabeledTextInputClass:GetValue()
	return self._value
end

function LabeledTextInputClass:GetMaxGraphemes()
	return self._MaxGraphemes
end

function LabeledTextInputClass:SetMaxGraphemes(newValue)
	self._MaxGraphemes = newValue
end

function LabeledTextInputClass:SetValue(newValue)
	if self._value ~= newValue then
		self._textBox.Text = newValue
	end
end

return LabeledTextInputClass
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="7">
        <Properties>
          <string name="Name">ProgressFrame</string>
          <string name="Source">----------------------------------------
--
-- ProgressFrame.lua
--
-- Creates a frame that has a progress bar.
--
----------------------------------------

local GuiUtilities = require(script.Parent.GuiUtilities)

local kWidth = 400
local kHeight = 160

local kStandardHMargin = 10
local kStandardVMargin = 5
local kBarHeight = 25
local kButtonHeight = 30

local kTitleBarHeight = 25

ProgressFrameClass = {}
ProgressFrameClass.__index = ProgressFrameClass

function ProgressFrameClass.new(nameSuffix, labelText, initValue, initDisabled)
	local self = {}
	setmetatable(self, ProgressFrameClass)

	self._frame = Instance.new("Frame")
	self._frame.Name = "ProgressFrame"
	self._frame.Position = UDim2.new(0.5, -kWidth/2, 0, 0)
	self._frame.Size = UDim2.new(0, kWidth, 0, kHeight)
	self._frame.Style = Enum.FrameStyle.DropShadow

	self._frame.Visible = false

	self._bar = Instance.new("Frame")
	self._bar.Name = "Bar"
	self._bar.Parent = self._frame
	self._bar.Position = UDim2.new(0, kStandardHMargin, 0.39, 0)
	self._bar.Size = UDim2.new(1, -2 * kStandardHMargin, 0, kBarHeight)

	self._fill = Instance.new("ImageLabel")
	self._fill.Name = "ImageLabel"
	self._fill.Parent = self._bar
	self._fill.Image = "rbxasset://textures/TerrainTools/progress_bar.png"
	self._fill.ImageColor3 = Color3.new(0, 0.9, 0.4)
	self._fill.ImageRectOffset = Vector2.new(0, 256)
	self._fill.ImageRectSize = Vector2.new(0, -100)
	self._fill.ScaleType = Enum.ScaleType.Stretch

	self._pauseButton = Instance.new("TextButton")
	self._pauseButton.Name = "PauseButton"
	self._pauseButton.Text = "Pause"
	self._pauseButton.Parent = self._frame
	self._pauseButton.Style = Enum.ButtonStyle.RobloxRoundDefaultButton
	self._pauseButton.Size = UDim2.new(0.5, -2 * kStandardHMargin, 0, kButtonHeight)
	self._pauseButton.Position = UDim2.new(0, kStandardHMargin, 1, -kStandardVMargin - kButtonHeight)

	self._cancelButton = Instance.new("TextButton")
	self._cancelButton.Name = "CancelButton"
	self._cancelButton.Text = "Cancel"
	self._cancelButton.Parent = self._frame
	self._cancelButton.AnchorPoint = Vector2.new(1, 0)
	self._cancelButton.Style = Enum.ButtonStyle.RobloxRoundDefaultButton
	self._cancelButton.Size = UDim2.new(0.5, -2 * kStandardHMargin, 0, kButtonHeight)
	self._cancelButton.Position = UDim2.new(1, -kStandardHMargin, 1, -kStandardVMargin - kButtonHeight)

	self._titleLabel = Instance.new("TextLabel")
	self._titleLabel.Name = "TitleLabel"
	self._titleLabel.Text = "Progress"
	self._titleLabel.Parent = self._frame
	self._titleLabel.BackgroundTransparency = 0.75
	self._titleLabel.BackgroundColor3 = Color3.new(1, 1, 1)
	self._titleLabel.Size = UDim2.new(1, 0, 0, kTitleBarHeight)

	self:_FixFont(self._pauseButton)
	self:_FixFont(self._cancelButton)
	self:_FixFont(self._titleLabel)

	return self
end

function ProgressFrameClass:_FixFont(frame)
	frame.Font = Enum.Font.SourceSansBold
	frame.TextColor3 = Color3.new(1, 1, 1)
	frame.TextSize = 18
end

function ProgressFrameClass:GetFrame() 
	return self._frame
end

function ProgressFrameClass:GetPauseButton() 
	return self._pauseButton
end

function ProgressFrameClass:GetCancelButton() 
	return self._cancelButton
end

function ProgressFrameClass:GetFill() 
	return self._fill
end

return ProgressFrameClass</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="8">
        <Properties>
          <string name="Name">TabbableVector3Input</string>
          <string name="Source"><![CDATA[----------------------------------------
--
-- TabbableVector3Input.lua
--
-- Creates a frame containing a label and a text input control.
-- that can be linked to other TabbableVector3Input Copied mostly from LabeldTextInput
-- but will be replace when we go to Roact
----------------------------------------
local GuiUtilities = require(script.Parent.GuiUtilities)

local FIRST_COLUMN_WIDTH = 90
local FIRST_COLUMN_OFFSET = GuiUtilities.StandardLineLabelLeftMargin
local SECOND_COLUMN_OFFSET = FIRST_COLUMN_WIDTH + FIRST_COLUMN_OFFSET
local PADDING = 4

local FONT = Enum.Font.SourceSans
local FONT_SIZE = 14
local TEXTBOX_WIDTH = 120
local TEXTBOX_HEIGHT = 22 -- does not include padding
local TEXTBOX_LABEL_WIDTH = 16
local TEXTBOX_OFFSET = TEXTBOX_LABEL_WIDTH + PADDING
local TEXTBOX_SIZE_PADDING = TEXTBOX_OFFSET + FIRST_COLUMN_OFFSET

local LABEL_BACKGROUND_DARK_COLOR = Color3.fromRGB(53, 53, 53)
local LABEL_BACKGROUND_COLOR = Color3.fromRGB(245, 245, 245)
local BORDER_COLOR = Color3.fromRGB(182, 182, 182)
local BORDER_COLOR_DARK = Color3.fromRGB(26, 26, 26)
local SELECTED_BORDER_COLOR = Color3.fromRGB(0, 162, 255)
local WARNING_RED = Color3.fromRGB(216, 104, 104)

local DEFAULT_WARNING_MESSAGE = "Input is not a valid number."
TabbableVector3Input = {}
TabbableVector3Input.__index = TabbableVector3Input

function getTextBoxCheckFunc(self, index)
	return function()
		-- if we encounter a tab key, it will be consumed to pass focus to the next textBox
		if self._textBox[index].Text and string.find(self._textBox[index].Text, '\t') then
			-- remove the tab character since we consumed it
			self._textBox[index].Text = self._textBox[index].Text:gsub('\t', '')

			--hack to handle the focuslost case
			if not self._warning[index] then
				self._textFrame[index].BorderColor3 = BORDER_COLOR
			end

			local nextInd = index + 1
			if nextInd > 3 and self._nextTabTarget then
				self._nextTabTarget:CaptureFocus()
			else
				nextInd = nextInd > 3 and 1 or nextInd
				self._textBox[nextInd]:CaptureFocus()
			end
		end

		-- Never let the text be too long.
		-- Careful here: we want to measure number of graphemes, not characters,
		-- in the text, and we want to clamp on graphemes as well.
		if (utf8.len(self._textBox[index].Text) > self._MaxGraphemes) then
			local count = 0
			for start, stop in utf8.graphemes(self._textBox[index].Text) do
				count = count + 1
				if (count > self._MaxGraphemes) then
					-- We have gone one too far.
					-- clamp just before the beginning of this grapheme.
					self._textBox[index].Text = string.sub(self._textBox[index].Text, 1, start-1)
					break
				end
			end
			-- Don't continue with rest of function: the resetting of "Text" field
			-- above will trigger re-entry.  We don't need to trigger value
			-- changed function twice.
			return
		end

		local num = tonumber(self._textBox[index].Text)

		local validEntry, warningMessage
		if self._warningFunc then
			validEntry, warningMessage = self._warningFunc(self._textBox[index].Text, index)
		else
			validEntry = num or self._textBox[index].Text == ''
			warningMessage = DEFAULT_WARNING_MESSAGE
		end

		if validEntry then
			if self._warning[index] then
				self._warning[index].Parent = nil
				self._textFrame[index].BorderColor3 = BORDER_COLOR
				self._warning[index] = nil
			end
			self._value[index] = num
		else
			-- layour Orders of the index are already set to (2*index - 1)
			-- this way errors for the appropriate index are just 2 * index
			if not self._warning[index] then
				local warning = Instance.new("TextLabel")
				warning.BackgroundTransparency = 1
				warning.Text = warningMessage
				warning.Font = FONT
				warning.TextSize = FONT_SIZE
				warning.TextColor3 = WARNING_RED
				warning.TextXAlignment = Enum.TextXAlignment.Left
				warning.Size = UDim2.new(1, 0, 0, TEXTBOX_HEIGHT)
				warning.LayoutOrder = index * 2
				warning.Parent = self._textBoxFrame
				self._warning[index] = warning

				self._textFrame[index].BorderColor3 = WARNING_RED
			else
				self._warning[index].Text = warningMessage
			end
		end
	end
end

local function textBoxHelper(self, parent, name, initialValues, index, layoutOrder)
	local initTheme = settings().Studio["UI Theme"]

	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0, TEXTBOX_WIDTH, 0, TEXTBOX_HEIGHT)
	frame.BorderColor3 = initTheme == Enum.UITheme.Dark and BORDER_COLOR_DARK or BORDER_COLOR
	frame.BackgroundTransparency = 0
	frame.LayoutOrder = layoutOrder
	frame.Parent = parent
	self._textFrame[index] = frame

	local label = Instance.new("TextLabel")
	label.Text = name
	label.Size = UDim2.new(0, TEXTBOX_LABEL_WIDTH, 1, 0)
	label.BackgroundColor3 = initTheme == Enum.UITheme.Dark and LABEL_BACKGROUND_DARK_COLOR or LABEL_BACKGROUND_COLOR
	label.BorderSizePixel = 0
	label.Parent = frame

	local box = Instance.new("TextBox")
	box.ClearTextOnFocus = false
	box.PlaceholderText = ""
	box.Text = type(initialValues) == "table" and tostring(initialValues[index])
	box.Size = UDim2.new(1, -TEXTBOX_SIZE_PADDING, 1, 0)
	box.Position = UDim2.new(0, TEXTBOX_OFFSET, 0, 0)
	box.BackgroundTransparency = 1
	box.Font = FONT
	box.TextSize = FONT_SIZE
	box.TextXAlignment = Enum.TextXAlignment.Left
	box.Parent = frame
	self._textBox[index] = box

	box.Focused:connect(self:getChangeBorderColorFunc(index, SELECTED_BORDER_COLOR))
	box.FocusLost:connect(self:getChangeBorderColorFunc(index, BORDER_COLOR))
	box:GetPropertyChangedSignal("Text"):connect(getTextBoxCheckFunc(self, index))

	GuiUtilities.syncGuiElementFontColor(label)
	GuiUtilities.syncGuiElementFontColor(box)
	GuiUtilities.syncGuiElementInputFieldColor(box)
	GuiUtilities.syncGuiElementBackgroundColor(frame)

	--label color doesn't exist as a backgroundColor signal
	settings().Studio.ThemeChanged:connect(function()
		local currTheme = settings().Studio["UI Theme"]
		if currTheme == Enum.UITheme.Dark then
			label.BackgroundColor3 = LABEL_BACKGROUND_DARK_COLOR
			frame.BorderColor3 = BORDER_COLOR_DARK
		else
			label.BackgroundColor3 = LABEL_BACKGROUND_COLOR
			frame.BorderColor3 = BORDER_COLOR
		end
	end)

	if type(initialValues) == "table" then
		self._value[index] = initialValues[index]
	end

end

-- on selected blue color and revert back
function TabbableVector3Input:getChangeBorderColorFunc(index, color)
	return function()
		if not self._warning[index] then
			self._textFrame[index].BorderColor3 = color
		end
	end
end


function TabbableVector3Input.new(categoryLabel, initialValues)
	local self = {}
	setmetatable(self, TabbableVector3Input)

	-- Note: we are using "graphemes" instead of characters.
	-- In modern text-manipulation-fu, what with internationalization,
	-- emojis, etc, it's not enough to count characters, particularly when
	-- concerned with "how many <things> am I rendering?".
	-- We are using the
	self._MaxGraphemes = 10

	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(1, 0, 0, 0)
	frame.BackgroundTransparency = 1
	self._frame = frame

	local label = Instance.new("TextLabel")
	label.Text = categoryLabel
	label.Font = FONT
	label.TextSize = FONT_SIZE
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Size = UDim2.new(0, FIRST_COLUMN_WIDTH, 0, TEXTBOX_HEIGHT)
	label.Position = UDim2.new(0, FIRST_COLUMN_OFFSET, 0, 0)
	label.BorderSizePixel = 0
	label.BackgroundTransparency = 1
	label.Parent = frame
	self._label  = label

	local fieldFrame = Instance.new("Frame")
	fieldFrame.Position = UDim2.new(0, SECOND_COLUMN_OFFSET, 0, 0)
	fieldFrame.Size = UDim2.new(1, -SECOND_COLUMN_OFFSET, 0, 0)
	fieldFrame.BackgroundTransparency = 1
	fieldFrame.BorderSizePixel = 0
	fieldFrame.Parent = frame
	self._textBoxFrame = fieldFrame

	self._value = {}
	self._textBox = {}
	self._textFrame = {}
	self._warning = {}

	-- odd numbers in layout order are for textbox, and even numbers are for errors when they show up
	textBoxHelper(self, fieldFrame, 'X', initialValues, 1, 1)
	textBoxHelper(self, fieldFrame, 'Y', initialValues, 2, 3)
	textBoxHelper(self, fieldFrame, 'Z', initialValues, 3, 5)



	local uiLayout = Instance.new("UIListLayout")
	uiLayout.Padding = UDim.new(0, PADDING)
	uiLayout.SortOrder = Enum.SortOrder.LayoutOrder
	uiLayout.FillDirection = Enum.FillDirection.Vertical
	uiLayout.Parent = fieldFrame

	-- height depends on the number of textboxes and number of errors in those textboxes
	-- can not bind this to listen to absolute size change because
	-- we are at our limit of event re-entry here
	local function updateFrameSize()
		self._frame.Size = UDim2.new(1, 0, 0, uiLayout.AbsoluteContentSize.Y)
	end

	uiLayout:GetPropertyChangedSignal("AbsoluteContentSize"):connect(updateFrameSize)

	updateFrameSize()

	-- listen for theme color changes
	GuiUtilities.syncGuiElementFontColor(label)

	GuiUtilities.syncGuiElementBackgroundColor(frame)
	GuiUtilities.syncGuiElementBorderColor(frame)

	return self
end

function TabbableVector3Input:GetFrame()
	return self._frame
end

function TabbableVector3Input:GetVector3()
	if self._value[1] and self._value[2] and self._value[3] then
		return Vector3.new(self._value[1], self._value[2], self._value[3])
	end
	return nil
end

function TabbableVector3Input:GetMaxGraphemes()
	return self._MaxGraphemes
end

function TabbableVector3Input:SetMaxGraphemes(newValue)
	self._MaxGraphemes = newValue
end

-- expects function that takes 2 parameters and returns
-- whether current text is valid and if it's not, return
-- a msg as the second arg
-- param1 = current text in textbox
-- param2 = index of textbox
function TabbableVector3Input:SetWarningFunc(newFunc)
	self._warningFunc = newFunc
end

function TabbableVector3Input:SetValue(newValue)
	if self._value ~= newValue then
		self._textBox.Text = newValue
	end
end

function TabbableVector3Input:CaptureFocus()
	if self._textBox[1] then
		self._textBox[1]:CaptureFocus()
	end
end

function TabbableVector3Input:LinkToNextTabbableVector3Input(nextTarget)
	self._nextTabTarget = nextTarget
end

return TabbableVector3Input
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="9">
        <Properties>
          <string name="Name">VerticallyScalingListFrame</string>
          <string name="Source">----------------------------------------
--
-- VerticallyScalingListFrame
--
-- Creates a frame that organizes children into a list layout.
-- Will scale dynamically as children grow.
--
----------------------------------------
GuiUtilities = require(script.Parent.GuiUtilities)

VerticallyScalingListFrameClass = {}
VerticallyScalingListFrameClass.__index = VerticallyScalingListFrameClass

local kBottomPadding = 10

function VerticallyScalingListFrameClass.new(nameSuffix)
	local self = {}
	setmetatable(self, VerticallyScalingListFrameClass)

	self._resizeCallback = nil
	
	local frame = Instance.new('Frame')
	frame.Name = 'VSLFrame' .. nameSuffix
	frame.Size = UDim2.new(1, 0, 0, height)
	frame.BackgroundTransparency = 0
	frame.BorderSizePixel = 0
	GuiUtilities.syncGuiElementBackgroundColor(frame)

	self._frame = frame
	
	local uiListLayout = Instance.new('UIListLayout')
	uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	uiListLayout.Parent = frame
	self._uiListLayout = uiListLayout

	local function updateSizes()
		self._frame.Size = UDim2.new(1, 0, 0, uiListLayout.AbsoluteContentSize.Y)
		if (self._resizeCallback) then 
			self._resizeCallback()
		end
	end
	self._uiListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):connect(updateSizes)
	updateSizes()

	self._childCount = 0

	return self
end

function VerticallyScalingListFrameClass:AddBottomPadding()
	local frame = Instance.new("Frame")
	frame.Name = "BottomPadding"
	frame.BackgroundTransparency = 1
	frame.Size = UDim2.new(1, 0, 0, kBottomPadding)
	frame.LayoutOrder = 1000
	frame.Parent = self._frame
end

function VerticallyScalingListFrameClass:GetFrame()
	return self._frame
end

function VerticallyScalingListFrameClass:AddChild(childFrame)
	childFrame.LayoutOrder = self._childCount
	self._childCount = self._childCount + 1
	childFrame.Parent = self._frame
end

function VerticallyScalingListFrameClass:SetCallbackOnResize(callback)
	self._resizeCallback = callback
end

return VerticallyScalingListFrameClass</string>
        </Properties>
      </Item>
    </Item>
    <Item class="ModuleScript" referent="10">
      <Properties>
        <string name="Name">PNG</string>
        <string name="Source">---------------------------------------------------------------------------------------------
-- @ CloneTrooper1019, 2019
---------------------------------------------------------------------------------------------
-- [PNG Library]
--
--  A module for opening PNG files into a readable bitmap.
--  This implementation works with most PNG files.
--
---------------------------------------------------------------------------------------------

local PNG = {}
PNG.__index = PNG

local chunks = script.Chunks
local modules = script.Modules

local Deflate = require(modules.Deflate)
local Unfilter = require(modules.Unfilter)
local BinaryReader = require(modules.BinaryReader)

local function getBytesPerPixel(colorType)
	if colorType == 0 or colorType == 3 then
		return 1
	elseif colorType == 4 then
		return 2
	elseif colorType == 2 then
		return 3
	elseif colorType == 6 then
		return 4
	else
		return 0
	end
end

local function clampInt(value, min, max)
	local num = tonumber(value) or 0
	num = math.floor(num + .5)
	
	return math.clamp(num, min, max)
end

local function indexBitmap(file, x, y)
	local width = file.Width
	local height = file.Height
	
	local x = clampInt(x, 1, width) 
	local y = clampInt(y, 1, height)
	
	local bitmap = file.Bitmap
	local bpp = file.BytesPerPixel
	
	local i0 = ((x - 1) * bpp) + 1
	local i1 = i0 + bpp
	
	return bitmap[y], i0, i1
end

function PNG:GetPixel(x, y)
	local row, i0, i1 = indexBitmap(self, x, y)
	local colorType = self.ColorType
	
	local color, alpha do
		if colorType == 0 then
			local gray = unpack(row, i0, i1)
			color = Color3.fromHSV(0, 0, gray)
			alpha = 255
		elseif colorType == 2 then
			local r, g, b = unpack(row, i0, i1)
			color = Color3.fromRGB(r, g, b)
			alpha = 255
		elseif colorType == 3 then
			local palette = self.Palette
			local alphaData = self.AlphaData
			
			local index = unpack(row, i0, i1)
			index = index + 1
			
			if palette then
				color = palette[index]
			end
			
			if alphaData then
				alpha = alphaData[index]
			end
		elseif colorType == 4 then
			local gray, a = unpack(row, i0, i1)
			color = Color3.fromHSV(0, 0, gray)
			alpha = a
		elseif colorType == 6 then
			local r, g, b, a = unpack(row, i0, i1)
			color = Color3.fromRGB(r, g, b, a)
			alpha = a
		end
	end
	
	if not color then
		color = Color3.new()
	end
	
	if not alpha then
		alpha = 255
	end
	
	return color, alpha
end

function PNG.new(buffer)
	-- Create the reader.
	local reader = BinaryReader.new(buffer)
	
	-- Create the file object.
	local file =
	{
		Chunks = {};
		Metadata = {};
		
		Reading = true;
		ZlibStream = "";
	}
	
	-- Verify the file header.
	local header = reader:ReadString(8)
	
	if header ~= "\137PNG\r\n\26\n" then
		error("PNG - Input data is not a PNG file.", 2)
	end
	
	while file.Reading do
		local length = reader:ReadInt32()
		local chunkType = reader:ReadString(4)
		
		local data, crc
		
		if length > 0 then
			data = reader:ForkReader(length)
			crc = reader:ReadUInt32()
		end
		
		local chunk = 
		{
			Length = length;
			Type = chunkType;
			
			Data = data;
			CRC = crc;
		}
		
		local handler = chunks:FindFirstChild(chunkType)
		
		if handler then
			handler = require(handler)
			handler(file, chunk)
		end
		
		table.insert(file.Chunks, chunk)
	end
	
	-- Decompress the zlib stream.
	local success, response = pcall(function ()
		local result = {}
		local index = 0
		
		Deflate:InflateZlib
		{
			Input = BinaryReader.new(file.ZlibStream);
			
			Output = function (byte)
				index = index + 1
				result[index] = string.char(byte)
			end
		}
		
		return table.concat(result)
	end)
	
	if not success then
		error("PNG - Unable to unpack PNG data. " .. tostring(response), 2)
	end
	
	-- Grab expected info from the file.
	
	local width = file.Width
	local height = file.Height
	
	local bitDepth = file.BitDepth
	local colorType = file.ColorType
	
	local buffer = BinaryReader.new(response)
	file.ZlibStream = nil
	
	local bitmap = {}
	file.Bitmap = bitmap
	
	local channels = getBytesPerPixel(colorType)
	file.NumChannels = channels
	
	local bpp = math.max(1, channels * (bitDepth / 8))
	file.BytesPerPixel = bpp
	
	-- Unfilter the buffer and 
	-- load it into the bitmap.
	
	for row = 1, height do	
		local filterType = buffer:ReadByte()
		local scanline = buffer:ReadBytes(width * bpp, true)
		
		bitmap[row] = {}
		
		if filterType == 0 then
			-- None
			Unfilter:None(scanline, bitmap, bpp, row)
		elseif filterType == 1 then
			-- Sub
			Unfilter:Sub(scanline, bitmap, bpp, row)
		elseif filterType == 2 then
			-- Up
			Unfilter:Up(scanline, bitmap, bpp, row)
		elseif filterType == 3 then
			-- Average
			Unfilter:Average(scanline, bitmap, bpp, row)
		elseif filterType == 4 then
			-- Paeth
			Unfilter:Paeth(scanline, bitmap, bpp, row)
		end
	end
	
	return setmetatable(file, PNG)
end

return PNG</string>
      </Properties>
      <Item class="Folder" referent="11">
        <Properties>
          <string name="Name">Chunks</string>
        </Properties>
        <Item class="ModuleScript" referent="12">
          <Properties>
            <string name="Name">IEND</string>
            <string name="Source">local function IEND(file)
	file.Reading = nil
end

return IEND</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="13">
          <Properties>
            <string name="Name">bKGD</string>
            <string name="Source">local function bKGD(file, chunk)
	local data = chunk.Data
	
	local bitDepth = file.BitDepth
	local colorType = file.ColorType
	
	bitDepth = (2 ^ bitDepth) - 1
	
	if colorType == 3 then
		local index = data:ReadByte()
		file.BackgroundColor = file.Palette[index]
	elseif colorType == 0 or colorType == 4 then
		local gray = data:ReadUInt16() / bitDepth
		file.BackgroundColor = Color3.fromHSV(0, 0, gray)
	elseif colorType == 2 or colorType == 6 then
		local r = data:ReadUInt16() / bitDepth
		local g = data:ReadUInt16() / bitDepth
		local b = data:ReadUInt16() / bitDepth
		file.BackgroundColor = Color3.new(r, g, b)
	end
end

return bKGD</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="14">
          <Properties>
            <string name="Name">sRGB</string>
            <string name="Source">local function sRGB(file, chunk)
	local data = chunk.Data
	file.RenderIntent = data:ReadByte()
end

return sRGB</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="15">
          <Properties>
            <string name="Name">tRNS</string>
            <string name="Source">local function tRNS(file, chunk)
	local data = chunk.Data
	
	local bitDepth = file.BitDepth
	local colorType = file.ColorType
	
	bitDepth = (2 ^ bitDepth) - 1
	
	if colorType == 3 then
		local palette = file.Palette
		local alphaMap = {}
		
		for i = 1, #palette do
			local alpha = data:ReadByte()
			
			if not alpha then
				alpha = 255
			end
			
			alphaMap[i] = alpha
		end
		
		file.AlphaData = alphaMap
	elseif colorType == 0 then
		local grayAlpha = data:ReadUInt16()
		file.Alpha = grayAlpha / bitDepth
	elseif colorType == 2 then
		-- TODO: This seems incorrect...
		local r = data:ReadUInt16() / bitDepth
		local g = data:ReadUInt16() / bitDepth
		local b = data:ReadUInt16() / bitDepth
		file.Alpha = Color3.new(r, g, b)
	else
		error("PNG - Invalid tRNS chunk")
	end	
end

return tRNS</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="16">
          <Properties>
            <string name="Name">IHDR</string>
            <string name="Source">local function IHDR(file, chunk)
	local data = chunk.Data
	
	file.Width = data:ReadInt32();
	file.Height = data:ReadInt32();
	
	file.BitDepth = data:ReadByte();
	file.ColorType = data:ReadByte();
	
	file.Methods =
	{
		Compression = data:ReadByte();
		Filtering   = data:ReadByte();
		Interlace   = data:ReadByte();
	}
end

return IHDR</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="17">
          <Properties>
            <string name="Name">PLTE</string>
            <string name="Source">local function PLTE(file, chunk)
	if not file.Palette then
		file.Palette = {}
	end
	
	local data = chunk.Data
	local palette = data:ReadAllBytes()
	
	if #palette % 3 ~= 0 then
		error("PNG - Invalid PLTE chunk.")
	end
	
	for i = 1, #palette, 3 do
		local r = palette[i]
		local g = palette[i + 1]
		local b = palette[i + 2]
		
		local color = Color3.fromRGB(r, g, b)
		local index = #file.Palette + 1
		
		file.Palette[index] = color
	end
end

return PLTE</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="18">
          <Properties>
            <string name="Name">tIME</string>
            <string name="Source">local function tIME(file, chunk)
	local data = chunk.Data
	
	local timeStamp = 
	{
		Year  = data:ReadUInt16();
		Month = data:ReadByte();
		Day   = data:ReadByte();
		
		Hour   = data:ReadByte();
		Minute = data:ReadByte();
		Second = data:ReadByte();
	}
	
	file.TimeStamp = timeStamp
end

return tIME</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="19">
          <Properties>
            <string name="Name">IDAT</string>
            <string name="Source">local function IDAT(file, chunk)
	local crc = chunk.CRC
	local hash = file.Hash or 0
	
	local data = chunk.Data
	local buffer = data.Buffer
	
	file.Hash = bit32.bxor(hash, crc)
	file.ZlibStream = file.ZlibStream .. buffer
end

return IDAT</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="20">
          <Properties>
            <string name="Name">gAMA</string>
            <string name="Source">local function gAMA(file, chunk)
	local data = chunk.Data
	local value = data:ReadUInt32()
	file.Gamma = value / 10e4
end

return gAMA</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="21">
          <Properties>
            <string name="Name">cHRM</string>
            <string name="Source">local colors = {"White", "Red", "Green", "Blue"}

local function cHRM(file, chunk)
	local chrome = {}
	local data = chunk.Data
	
	for i = 1, 4 do
		local color = colors[i]
		
		chrome[color] =
		{
			[1] = data:ReadUInt32() / 10e4;
			[2] = data:ReadUInt32() / 10e4;
		}
	end
	
	file.Chromaticity = chrome
end

return cHRM</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="22">
          <Properties>
            <string name="Name">tEXt</string>
            <string name="Source">local function tEXt(file, chunk)
	local data = chunk.Data
	local key, value = "", ""
	
	for byte in data:IterateBytes() do
		local char = string.char(byte)
		
		if char == '\0' then
			key = value
			value = ""
		else
			value = value .. char
		end
	end
	
	file.Metadata[key] = value
end

return tEXt</string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="23">
        <Properties>
          <string name="Name">Modules</string>
        </Properties>
        <Item class="ModuleScript" referent="24">
          <Properties>
            <string name="Name">BinaryReader</string>
            <string name="Source">local BinaryReader = {}
BinaryReader.__index = BinaryReader

function BinaryReader.new(buffer)
	local reader = 
	{
		Position = 1;
		Buffer = buffer;
		Length = #buffer;
	}
	
	return setmetatable(reader, BinaryReader)
end

function BinaryReader:ReadByte()
	local buffer = self.Buffer
	local pos = self.Position
	
	if pos &lt;= self.Length then
		local result = buffer:sub(pos, pos)
		self.Position = pos + 1
		
		return result:byte()
	end
end

function BinaryReader:ReadBytes(count, asArray)
	local values = {}
	
	for i = 1, count do
		values[i] = self:ReadByte()
	end
	
	if asArray then
		return values
	end
	
	return unpack(values)
end

function BinaryReader:ReadAllBytes()
	return self:ReadBytes(self.Length, true)
end

function BinaryReader:IterateBytes()
	return function ()
		return self:ReadByte()
	end
end

function BinaryReader:TwosComplementOf(value, numBits)
	if value >= (2 ^ (numBits - 1)) then
		value = value - (2 ^ numBits)
	end
	
	return value
end

function BinaryReader:ReadUInt16()
	local upper, lower = self:ReadBytes(2)
	return (upper * 256) + lower
end

function BinaryReader:ReadInt16()
	local unsigned = self:ReadUInt16()
	return self:TwosComplementOf(unsigned, 16)
end

function BinaryReader:ReadUInt32()
	local upper = self:ReadUInt16()
	local lower = self:ReadUInt16()
	
	return (upper * 65536) + lower
end

function BinaryReader:ReadInt32()
	local unsigned = self:ReadUInt32()
	return self:TwosComplementOf(unsigned, 32)
end

function BinaryReader:ReadString(length)
    if length == nil then
        length = self:ReadByte()
    end
    
    local pos = self.Position
    local nextPos = math.min(self.Length, pos + length)
    
    local result = self.Buffer:sub(pos, nextPos - 1)
    self.Position = nextPos
    
    return result
end

function BinaryReader:ForkReader(length)
	local chunk = self:ReadString(length)
	return BinaryReader.new(chunk)
end

return BinaryReader</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="25">
          <Properties>
            <string name="Name">Deflate</string>
            <string name="Source">--[[

LUA MODULE

compress.deflatelua - deflate (and zlib) implemented in Lua.

DESCRIPTION

This is a pure Lua implementation of decompressing the DEFLATE format,
including the related zlib format.

Note: This library only supports decompression.
Compression is not currently implemented.

REFERENCES

[1] DEFLATE Compressed Data Format Specification version 1.3
http://tools.ietf.org/html/rfc1951
[2] GZIP file format specification version 4.3
http://tools.ietf.org/html/rfc1952
[3] http://en.wikipedia.org/wiki/DEFLATE
[4] pyflate, by Paul Sladen
http://www.paul.sladen.org/projects/pyflate/
[5] Compress::Zlib::Perl - partial pure Perl implementation of
Compress::Zlib
http://search.cpan.org/~nwclark/Compress-Zlib-Perl/Perl.pm

LICENSE

(c) 2008-2011 David Manura.  Licensed under the same terms as Lua (MIT).
    Heavily modified by Max G. (2019)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
(end license)
--]]

local Deflate = {}

local band = bit32.band
local lshift = bit32.lshift
local rshift = bit32.rshift

local BTYPE_NO_COMPRESSION = 0
local BTYPE_FIXED_HUFFMAN = 1
local BTYPE_DYNAMIC_HUFFMAN = 2

local lens = -- Size base for length codes 257..285
{
	[0] = 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258
}

local lext = -- Extra bits for length codes 257..285
{
	[0] = 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
	3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0
}

local dists = -- Offset base for distance codes 0..29
{
	[0] = 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
	257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
	8193, 12289, 16385, 24577
}

local dext = -- Extra bits for distance codes 0..29
{
	[0] = 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
	7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
	12, 12, 13, 13
}

local order = -- Permutation of code length codes
{
	16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 
	11, 4, 12, 3, 13, 2, 14, 1, 15
}

-- Fixed literal table for BTYPE_FIXED_HUFFMAN
local fixedLit = {0, 8, 144, 9, 256, 7, 280, 8, 288}

 -- Fixed distance table for BTYPE_FIXED_HUFFMAN
local fixedDist = {0, 5, 32}

local function createState(bitStream)
	local state = 
	{
		Output = bitStream;
		Window = {};
		Pos = 1;
	}
	
	return state
end

local function write(state, byte)
	local pos = state.Pos
	state.Output(byte)
	state.Window[pos] = byte
	state.Pos = pos % 32768 + 1  -- 32K
end

local function memoize(fn)
	local meta = {}
	local memoizer = setmetatable({}, meta)
	
	function meta:__index(k)
		local v = fn(k)
		memoizer[k] = v
		
		return v
	end
	
	return memoizer
end

-- small optimization (lookup table for powers of 2)
local pow2 = memoize(function (n) 
	return 2 ^ n 
end)

-- weak metatable marking objects as bitstream type
local isBitStream = setmetatable({}, { __mode = 'k' })

local function createBitStream(reader)
	local buffer = 0
	local bitsLeft = 0
	
	local stream = {}
	isBitStream[stream] = true
	
	function stream:GetBitsLeft()
		return bitsLeft
	end
	
	function stream:Read(count)
		count = count or 1
		
		while bitsLeft &lt; count do
			local byte = reader:ReadByte()
			
			if not byte then 
				return 
			end
			
			buffer = buffer + lshift(byte, bitsLeft)
			bitsLeft = bitsLeft + 8
		end
		
		local bits
		
		if count == 0 then
			bits = 0
		elseif count == 32 then
			bits = buffer
			buffer = 0
		else
			bits = band(buffer, rshift(2^32 - 1, 32 - count))
			buffer = rshift(buffer, count)
		end
		
		bitsLeft = bitsLeft - count
		return bits
	end
	
	return stream
end

local function getBitStream(obj)
	if isBitStream[obj] then
		return obj
	end
	
	return createBitStream(obj)
end

local function sortHuffman(a, b)
	return a.NumBits == b.NumBits and a.Value &lt; b.Value or a.NumBits &lt; b.NumBits
end

local function msb(bits, numBits)
	local res = 0
		
	for i = 1, numBits do
		res = lshift(res, 1) + band(bits, 1)
		bits = rshift(bits, 1)
	end
		
	return res
end

local function createHuffmanTable(init, isFull)
	local hTable = {}
	
	if isFull then
		for val, numBits in pairs(init) do
			if numBits ~= 0 then
				hTable[#hTable + 1] = 
				{
					Value = val;
					NumBits = numBits;
				}
			end
		end
	else
		for i = 1, #init - 2, 2 do
			local firstVal = init[i]
			
			local numBits = init[i + 1]
			local nextVal = init[i + 2]
			
			if numBits ~= 0 then
				for val = firstVal, nextVal - 1 do
					hTable[#hTable + 1] = 
					{
						Value = val;
						NumBits = numBits;
					}
				end
			end
		end
	end
	
	table.sort(hTable, sortHuffman)
	
	local code = 1
	local numBits = 0
	
	for i, slide in ipairs(hTable) do
		if slide.NumBits ~= numBits then
			code = code * pow2[slide.NumBits - numBits]
			numBits = slide.NumBits
		end
		
		slide.Code = code
		code = code + 1
	end
	
	local minBits = math.huge
	local look = {}
	
	for i, slide in ipairs(hTable) do
		minBits = math.min(minBits, slide.NumBits)
		look[slide.Code] = slide.Value
	end

	local firstCode = memoize(function (bits) 
		return pow2[minBits] + msb(bits, minBits) 
	end)
	
	function hTable:Read(bitStream)
		local code = 1 -- leading 1 marker
		local numBits = 0
		
		while true do
			if numBits == 0 then  -- small optimization (optional)
				local index = bitStream:Read(minBits)
				numBits = numBits + minBits
				code = firstCode[index]
			else
				local bit = bitStream:Read()
				numBits = numBits + 1
				code = code * 2 + bit -- MSB first
			end
			
			local val = look[code]
			
			if val then
				return val
			end
		end
	end
	
	return hTable
end

local function parseZlibHeader(bitStream)
	-- Compression Method
	local cm = bitStream:Read(4)
	
	-- Compression info
	local cinfo = bitStream:Read(4)  
	
	-- FLaGs: FCHECK (check bits for CMF and FLG)   
	local fcheck = bitStream:Read(5)
	
	-- FLaGs: FDICT (present dictionary)
	local fdict = bitStream:Read(1)
	
	-- FLaGs: FLEVEL (compression level)
	local flevel = bitStream:Read(2)
	
	-- CMF (Compresion Method and flags)
	local cmf = cinfo * 16  + cm
	
	-- FLaGs
	local flg = fcheck + fdict * 32 + flevel * 64 
	
	if cm ~= 8 then -- not "deflate"
		error("unrecognized zlib compression method: " .. cm)
	end
	
	if cinfo > 7 then
		error("invalid zlib window size: cinfo=" .. cinfo)
	end
	
	local windowSize = 2 ^ (cinfo + 8)
	
	if (cmf * 256 + flg) % 31 ~= 0 then
		error("invalid zlib header (bad fcheck sum)")
	end
	
	if fdict == 1 then
		error("FIX:TODO - FDICT not currently implemented")
	end
	
	return windowSize
end

local function parseHuffmanTables(bitStream)
	local numLits  = bitStream:Read(5) -- # of literal/length codes - 257
	local numDists = bitStream:Read(5) -- # of distance codes - 1
	local numCodes = bitStream:Read(4) -- # of code length codes - 4
	
	local codeLens = {}
	
	for i = 1, numCodes + 4 do
		local index = order[i]
		codeLens[index] = bitStream:Read(3)
	end
	
	codeLens = createHuffmanTable(codeLens, true)

	local function decode(numCodes)
		local init = {}
		local numBits
		local val = 0
		
		while val &lt; numCodes do
			local codeLen = codeLens:Read(bitStream)
			local numRepeats
			
			if codeLen &lt;= 15 then
				numRepeats = 1
				numBits = codeLen
			elseif codeLen == 16 then
				numRepeats = 3 + bitStream:Read(2)
			elseif codeLen == 17 then
				numRepeats = 3 + bitStream:Read(3)
				numBits = 0
			elseif codeLen == 18 then
				numRepeats = 11 + bitStream:Read(7)
				numBits = 0
			end
			
			for i = 1, numRepeats do
				init[val] = numBits
				val = val + 1
			end
		end
		
		return createHuffmanTable(init, true)
	end

	local numLitCodes = numLits + 257
	local numDistCodes = numDists + 1
	
	local litTable = decode(numLitCodes)
	local distTable = decode(numDistCodes)
	
	return litTable, distTable
end

local function parseCompressedItem(bitStream, state, litTable, distTable)
	local val = litTable:Read(bitStream)
	
	if val &lt; 256 then -- literal
		write(state, val)
	elseif val == 256 then -- end of block
		return true
	else
		local lenBase = lens[val - 257]
		local numExtraBits = lext[val - 257]
		
		local extraBits = bitStream:Read(numExtraBits)
		local len = lenBase + extraBits
		
		local distVal = distTable:Read(bitStream)
		local distBase = dists[distVal]
		
		local distNumExtraBits = dext[distVal]
		local distExtraBits = bitStream:Read(distNumExtraBits)
		
		local dist = distBase + distExtraBits
		
		for i = 1, len do
			local pos = (state.Pos - 1 - dist) % 32768 + 1
			local byte = assert(state.Window[pos], "invalid distance")
			write(state, byte)
		end
	end
	
	return false
end

local function parseBlock(bitStream, state)
	local bFinal = bitStream:Read(1)
	local bType = bitStream:Read(2)
	
	if bType == BTYPE_NO_COMPRESSION then
		local left = bitStream:GetBitsLeft()
		bitStream:Read(left)
		
		local len = bitStream:Read(16)
		local nlen = bitStream:Read(16)

		for i = 1, len do
			local byte = bitStream:Read(8)
			write(state, byte)
		end
	elseif bType == BTYPE_FIXED_HUFFMAN or bType == BTYPE_DYNAMIC_HUFFMAN then
		local litTable, distTable

		if bType == BTYPE_DYNAMIC_HUFFMAN then
			litTable, distTable = parseHuffmanTables(bitStream)
		else
			litTable = createHuffmanTable(fixedLit)
			distTable = createHuffmanTable(fixedDist)
		end
		
		repeat until parseCompressedItem(bitStream, state, litTable, distTable)
	else
		error("unrecognized compression type")
	end

	return bFinal ~= 0
end

function Deflate:Inflate(io)
	local state = createState(io.Output)
	local bitStream = getBitStream(io.Input)
	
	repeat until parseBlock(bitStream, state)
end

function Deflate:InflateZlib(io)
	local bitStream = getBitStream(io.Input)
	local windowSize = parseZlibHeader(bitStream)
	
	self:Inflate
	{
		Input = bitStream;
		Output = io.Output;
	}
	
	local bitsLeft = bitStream:GetBitsLeft()
	bitStream:Read(bitsLeft)
end

return Deflate</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="26">
          <Properties>
            <string name="Name">Unfilter</string>
            <string name="Source">local Unfilter = {}

function Unfilter:None(scanline, pixels, bpp, row)
	for i = 1, #scanline do
		pixels[row][i] = scanline[i]
	end
end

function Unfilter:Sub(scanline, pixels, bpp, row)
	for i = 1, bpp do
		pixels[row][i] = scanline[i]
	end
	
	for i = bpp + 1, #scanline do
		local x = scanline[i]
		local a = pixels[row][i - bpp]
		pixels[row][i] = bit32.band(x + a, 0xFF)
	end
end

function Unfilter:Up(scanline, pixels, bpp, row)
	if row > 1 then
		local upperRow = pixels[row - 1]
		
		for i = 1, #scanline do
			local x = scanline[i]
			local b = upperRow[i]
			pixels[row][i] = bit32.band(x + b, 0xFF)
		end
	else
		self:None(scanline, pixels, bpp, row)
	end
end

function Unfilter:Average(scanline, pixels, bpp, row)
	if row > 1 then
		for i = 1, bpp do
			local x = scanline[i]
			local b = pixels[row - 1][i]
			
			b = bit32.rshift(b, 1)
			pixels[row][i] = bit32.band(x + b, 0xFF)
		end
		
		for i = bpp + 1, #scanline do
			local x = scanline[i]
			local b = pixels[row - 1][i]
			
			local a = pixels[row][i - bpp]
			local ab = bit32.rshift(a + b, 1)
			
			pixels[row][i] = bit32.band(x + ab, 0xFF)
		end
	else
		for i = 1, bpp do
			pixels[row][i] = scanline[i]
		end
	
		for i = bpp + 1, #scanline do
			local x = scanline[i]
			local b = pixels[row - 1][i]
			
			b = bit32.rshift(b, 1)
			pixels[row][i] = bit32.band(x + b, 0xFF)
		end
	end
end

function Unfilter:Paeth(scanline, pixels, bpp, row)
	if row > 1 then
		local pr
		
		for i = 1, bpp do
			local x = scanline[i]
			local b = pixels[row - 1][i]
			pixels[row][i] = bit32.band(x + b, 0xFF)
		end
		
		for i = bpp + 1, #scanline do
			local a = pixels[row][i - bpp]
			local b = pixels[row - 1][i]
			local c = pixels[row - 1][i - bpp]
			
			local x = scanline[i]
			local p = a + b - c
			
			local pa = math.abs(p - a)
			local pb = math.abs(p - b)
			local pc = math.abs(p - c)
			
			if pa &lt;= pb and pa &lt;= pc then
				pr = a
			elseif pb &lt;= pc then
				pr = b
			else
				pr = c
			end
			
			pixels[row][i] = bit32.band(x + pr, 0xFF)
		end
	else
		self:Sub(scanline, pixels, bpp, row)
	end
end

return Unfilter</string>
          </Properties>
        </Item>
      </Item>
    </Item>
    <Item class="Folder" referent="27">
      <Properties>
        <string name="Name">Plugin</string>
      </Properties>
      <Item class="ModuleScript" referent="28">
        <Properties>
          <string name="Name">HeightMapper</string>
          <string name="Source">------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @ CloneTrooper1019, 2019 
-- HeightMapper.lua 
------------------------------------------------------------------------------------------------------------------------------------------------------------
-- This module attempts to recreate the logic behind Roblox's original
-- terrain importer. Its not exactly 1:1, but its pretty close, and the
-- user experience should be a lot more responsive.
--
-- There are a few primary differences at the moment:
--
-- # Terrain is loaded with a scanline like the generator.
-- # The heightmap isn't generated as a sheet, it rises from the ground.
-- # Since it utilizes FillBlock, there isn't much smoothing to the terrain.
-- # Transparency is a considered factor in the height map to avoid random spikes!
--
------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Dependencies
------------------------------------------------------------------------------------------------------------------------------------------------------------

local project = script.Parent.Parent
local PNG = require(project.PNG)

local RunService = game:GetService("RunService")

-- MATERIAL_COLORS stores the default material colors
-- for all of the terrain materials as Vector3 objects
-- Doing this so its easier to measure differences
-- between colors via '(a - b).Magnitude'

local MATERIAL_COLORS = 
{
	Asphalt     = Vector3.new(115, 123, 107);
	Basalt      = Vector3.new( 30,  30,  37);
	Brick       = Vector3.new(138,  86,  62);
	Cobblestone = Vector3.new(132, 123,  90);
	Concrete    = Vector3.new(127, 102,  63);
	CrackedLava = Vector3.new(232, 156,  74);
	Glacier     = Vector3.new(101, 176, 234);
	Grass       = Vector3.new(106, 127,  63);
	Ground      = Vector3.new(102,  92,  59);
	Ice         = Vector3.new(129, 194, 224);
	LeafyGrass  = Vector3.new(115, 132,  74);
	Limestone   = Vector3.new(206, 173, 148);
	Mud         = Vector3.new( 58,  46,  36);
	Pavement    = Vector3.new(148, 148, 140);
	Rock        = Vector3.new(102, 108, 111);
	Salt        = Vector3.new(198, 189, 181);
	Sand        = Vector3.new(143, 126,  95);
	Sandstone   = Vector3.new(137,  90,  71);
	Slate       = Vector3.new( 63, 127, 107);
	Snow        = Vector3.new(195, 199, 218);
	Water       = Vector3.new( 12,  84,  92);
	WoodPlanks  = Vector3.new(139, 109,  79);
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Utilities
------------------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------
-- double getLuminance(Color3 color)
---------------------------------------------------------------------------------
-- Computes the relative luminance of the provided
-- Color3 value as a number in the [0-1] range.
---------------------------------------------------------------------------------

local function getLuminance(color)
	return 0.2126 * color.R
	     + 0.7152 * color.G
	     + 0.0722 * color.B
end

---------------------------------------------------------------------------------
-- Vector3 colorToVector3(Color3 color)
---------------------------------------------------------------------------------
-- Converts a Color3 value into a Vector3 with
-- the RGB coordinates in a [0-255] range.
---------------------------------------------------------------------------------

local function colorToVector3(color)
	local r = color.R * 255
	local g = color.G * 255
	local b = color.B * 255
	
	return Vector3.new(r, g, b)
end

---------------------------------------------------------------------------------
-- Material getClosestMaterial(Color3 targetColor)
---------------------------------------------------------------------------------
-- Takes a Color3 value and returns the terrain material
-- whose color is closest to matching the provided color.
---------------------------------------------------------------------------------

local function getClosestMaterial(targetColor)
	local bestMat, bestDist = nil, math.huge
	local target = colorToVector3(targetColor)
	
	for mat, color in pairs(MATERIAL_COLORS) do
		local dist = (color - target).Magnitude
		
		if dist &lt; bestDist then
			bestMat = mat
			bestDist = dist
			
			if bestDist &lt; 0.01 then
				break
			end
		end
	end
	
	return bestMat
end

---------------------------------------------------------------------------------
-- Tuple&lt;Color3, double> sampleBilinear(PNG image, double x, double y)
---------------------------------------------------------------------------------
-- Takes an image and two floating point XY coordinates,
-- and samples the surrounding pixels to create a blended
-- color/alpha value pair, effectively stretching the image.
---------------------------------------------------------------------------------

local function sampleBilinear(image, x, y)
	local x0 = math.floor(x)
	local y0 = math.floor(y)
	
	local x1 = math.ceil(x)
	local y1 = math.ceil(y)
	
	local c00, a00 = image:GetPixel(x0, y0)
	local c01, a01 = image:GetPixel(x0, y1)
	
	local c10, a10 = image:GetPixel(x1, y0)
	local c11, a11 = image:GetPixel(x1, y1)
	
	local c0 = c00:Lerp(c01, y - y0)
	local c1 = c10:Lerp(c11, y - y0)
	
	local a0 = a00 + ((a01 - a00) * (y - y0))
	local a1 = a10 + ((a11 - a10) * (y - y0))
	
	local color = c0:Lerp(c1, x - x0)
	local alpha = a0 + ((a1 - a0) * (x - x0))
	
	return color, alpha
end

------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Height Mapper
------------------------------------------------------------------------------------------------------------------------------------------------------------

local HeightMapper = {}
HeightMapper.__index = HeightMapper

---------------------------------------------------------------------------------
-- HeightMapper HeightMapper.new(BindableEvent update = nil)
---------------------------------------------------------------------------------
-- Creates a new HeightMapper, with the option to provide a BindableEvent that
-- is fired with a number between 0-1 to indicate the importer's progress.
---------------------------------------------------------------------------------

function HeightMapper.new(update)
	local mapper = {}
	
	if typeof(update) == "Instance" then
		if update:IsA("BindableEvent") then
			mapper.Updated = update
		end
	end
	
	return setmetatable(mapper, HeightMapper)
end

---------------------------------------------------------------------------------
-- void HeightMapper:_UpdateProgress(double percent)
---------------------------------------------------------------------------------
-- Fires the HeightMapper's updated event with the provided percent,
-- if an update event is mounted to the HeightMapper.
---------------------------------------------------------------------------------

function HeightMapper:_UpdateProgress(percent)
	if self.Updated then
		self.Updated:Fire(percent)
	end
end

---------------------------------------------------------------------------------
-- void HeightMapper:Import(Region3 region, PNG heightMap, PNG colorMap = nil)
---------------------------------------------------------------------------------
-- Generates a terrain heightmap using the provided Region3 
-- to position and scale the terrain. 
-- 
-- The height map is based on the luminance of each pixel in the 
-- provided height map file. 
--
-- The color map is optional, and attempts to match each color
-- to the nearest terrain material color.
---------------------------------------------------------------------------------

function HeightMapper:Import(region, heightMap, colorMap)
	if self.Busy then
		warn("Already importing terrain!")
		return
	end
	
	local cf = region.CFrame
	local size = region.Size
	
	local corner0 = cf * (size / -2)
	local corner1 = cf * (size /  2)
	
	local xMin = corner0.X
	local xMax = corner1.X
	
	local yMin = corner0.Y
	local yMax = corner1.Y
	
	local zMin = corner0.Z
	local zMax = corner1.Z
	
	local terrain = workspace.Terrain
	local coolDown = 0
	
	warn("Importing...")
	
	self.Busy = true
	self:_UpdateProgress(0)
	
	for x = xMin, xMax, 4 do
		local sx = (x - xMin) / (xMax - xMin)
		
		local hx = heightMap.Width * sx
		local cx = colorMap and colorMap.Width * sx
		
		for z = zMin, zMax, 4 do
			local sz = (z - zMin) / (zMax - zMin)
			
			local hz = heightMap.Height * sz
			local cz = colorMap and colorMap.Height * sz
			
			-- Sample the height
			local height, alpha = sampleBilinear(heightMap, hx, hz)
			height = getLuminance(height) * (yMax - yMin)
			
			if height >= 4 and alpha > 0 then
				-- Sample the material
				local material = "Concrete"
				local matAlpha = 255
				
				if colorMap then
					local color, alpha = sampleBilinear(colorMap, cx, cz)
					material = getClosestMaterial(color)
					matAlpha = alpha
				end
				
				if matAlpha > 0 then
					-- Generate the block
					local cf = CFrame.new(x, cf.Y + (height / 2), z)
					local size = Vector3.new(4, height, 4)
					
					terrain:FillBlock(cf, size, material)
					coolDown = coolDown + 1
					
					if (coolDown % 1000) == 0 then
						self:_UpdateProgress(sx)
						RunService.Heartbeat:Wait()
					end
				end
			end
		end
	end
	
	self:_UpdateProgress(1)
	self.Busy = false
end

return HeightMapper

------------------------------------------------------------------------------------------------------------------------------------------------------------</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="29">
        <Properties>
          <string name="Name">ImageSelector</string>
          <string name="Source"><![CDATA[--[[
	Author - 24RightAngles
	Modified by CloneTrooper1019
	used to select images for file import in the terrain editor
]]

-- HACK: Using the TeleportService because keys & values set in
--       GetTeleportSetting/SetTeleportSetting persist for the
--       duration of the Roblox Studio session ONLY. Its needed 
--       to work around a bug with File:GetTemporaryId() giving
--       the wrong rbxtemp:// urls half the time.

local StudioService = game:GetService("StudioService")
local TeleportService = game:GetService("TeleportService")

local project = script.Parent.Parent
local PNG = require(project.PNG)

local LIGHT_IMAGE  = "rbxasset://textures/TerrainTools/import_select_image.png"
local DARK_IMAGE   = "rbxasset://textures/TerrainTools/import_selectImg_dark.png"
local DELETE_IMAGE = "rbxasset://textures/TerrainTools/import_delete.png"
local EDIT_IMAGE   = "rbxasset://textures/TerrainTools/import_edit.png"

local IMAGE_BUTTON_SIZE = UDim2.new(0, 60, 0, 60)
local OPTION_IMAGE_SIZE = UDim2.new(0, 16, 0, 16)
local FRAME_SIZE = UDim2.new(0, 108, 0, 60)
local PADDING = 4

local ImageSelector = {}
ImageSelector.__index = ImageSelector

function ImageSelector.new(supportedFormats)
	local self = {}
	setmetatable(self, ImageSelector)

	self._selectedCallback = nil
	self._selectedFile = nil
	self._acceptedFormats = supportedFormats

	self._frame = Instance.new("Frame")
	self._frame.Size = FRAME_SIZE
	self._frame.BackgroundTransparency = 1

	local formatting = Instance.new("UIListLayout")
	formatting.SortOrder = Enum.SortOrder.LayoutOrder
	formatting.FillDirection = Enum.FillDirection.Horizontal
	formatting.VerticalAlignment = Enum.VerticalAlignment.Bottom
	formatting.Padding = UDim.new(0, PADDING)
	formatting.Parent = self._frame

	local initTheme = settings().Studio["UI Theme"]
	self._fallbackImage = initTheme == Enum.UITheme.Dark and DARK_IMAGE or LIGHT_IMAGE;

	self._imageButton = Instance.new("ImageButton")
	self._imageButton.Name = "SelectedImage"
	self._imageButton.Image = self._fallbackImage
	self._imageButton.Size = IMAGE_BUTTON_SIZE
	self._imageButton.BorderSizePixel = 0
	self._imageButton.BackgroundTransparency = 1
	self._imageButton.LayoutOrder = 1
	self._imageButton.Parent = self._frame
	self._imageButton.MouseButton1Click:connect(function()
		self:selectImage();
		self:updateOptionButtonVisibility()
	end)

	self._editButton = Instance.new("ImageButton")
	self._editButton.Name = "ReselectButton"
	self._editButton.Image = EDIT_IMAGE
	self._editButton.Size = OPTION_IMAGE_SIZE
	self._editButton.BorderSizePixel = 0
	self._editButton.BackgroundTransparency = 1
	self._editButton.ImageTransparency = 1
	self._editButton.LayoutOrder = 2
	self._editButton.Parent = self._frame
	self._editButton.MouseButton1Click:connect(function()
		if self._editButton.Active then
			self:selectImage()
		end
	end)

	self._deleteButton = Instance.new("ImageButton")
	self._deleteButton.Name = "ClearButton"
	self._deleteButton.Image = DELETE_IMAGE
	self._deleteButton.Size = OPTION_IMAGE_SIZE
	self._deleteButton.BorderSizePixel = 0
	self._deleteButton.BackgroundTransparency = 1
	self._deleteButton.LayoutOrder = 3
	self._deleteButton.Parent = self._frame
	self._deleteButton.MouseButton1Click:connect(function()
		if self._editButton.Active then
			self:clearImage()
			self:updateOptionButtonVisibility()
		end
	end)

	self:updateOptionButtonVisibility()

	--replace image when darkthemedarktheme
	settings().Studio.ThemeChanged:connect(function()
		if self._imageButton.Image == self._fallbackImage then
			local currTheme = settings().Studio.Theme
			
			if currTheme.Name == "Dark" then
				self._fallbackImage = DARK_IMAGE
			else
				self._fallbackImage = LIGHT_IMAGE
			end
			
			self._imageButton.Image = self._fallbackImage
		end
	end)

	return self
end

function ImageSelector:getFrame()
	return self._frame
end

-- edit and delete buttons should only be visible when
-- the image has been selected
function ImageSelector:updateOptionButtonVisibility()
	if self._selectedFile then
		self._editButton.Active = true
		self._editButton.ImageTransparency = 0
		self._deleteButton.Active = true
		self._deleteButton.ImageTransparency = 0
	else
		self._editButton.Active = false
		self._editButton.ImageTransparency = 1
		self._deleteButton.Active = false
		self._deleteButton.ImageTransparency = 1
	end
end

function ImageSelector:getTemporaryId()
	local file = self._selectedFile
	local img = self._selectedPng
	
	if file and img then
		local hash = string.format("PNG_%x", img.Hash)
		local id = TeleportService:GetTeleportSetting(hash)
		
		if not id then
			id = file:GetTemporaryId()
			TeleportService:SetTeleportSetting(hash, id)
		end
		
		return id
	end
end

function ImageSelector:selectImage()
	local img = StudioService:PromptImportFile(self._acceptedFormats)
	
	if img then
		local success, response = pcall(function ()
			local buffer = img:GetBinaryContents()
			return PNG.new(buffer)
		end)
		
		if success then
			self._selectedFile = img
			self._selectedPng = response
			
			if self._imageButton then
				local id = self:getTemporaryId()
				self._imageButton.Image = id
				
				if self._selectedCallback then
					self._selectedCallback()
				end
			end
		else
			warn("Error: Could not open this PNG file!")
			warn(response)
		end
	end
end

function ImageSelector:clearImage()
	self._imageButton.Image = self._fallbackImage
	self._selectedFile = nil
end

function ImageSelector:imageSelected()
	return self._selectedFile ~= nil
end

function ImageSelector:getBinary()
	if self._selectedFile then
		return self._selectedFile:GetBinaryContents()
	end
end

function ImageSelector:getPngFile()
	if self._selectedPng then
		return self._selectedPng
	end
end

function ImageSelector:setImageSelectedCallback(selectedCallback)
	self._selectedCallback = selectedCallback
end

return ImageSelector
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="30">
        <Properties>
          <string name="Name">TerrainImporter</string>
          <string name="Source">-- 24RightAngles
-- Modified by CloneTrooper1019

local module = {}

local importer = script.Parent
local core = importer.Parent
local modules = core.Modules

local GuiUtilities = require(modules.GuiUtilities)
local ProgressFrame = require(modules.ProgressFrame)
local CustomTextButton = require(modules.CustomTextButton)
local LabeledTextInput = require(modules.LabeledTextInput)
local ImageButtonWithText = require(modules.ImageButtonWithText)
local TabbableVector3Input = require(modules.TabbableVector3Input)
local CollapsibleTitledSection = require(modules.CollapsibleTitledSection)
local VerticallyScalingListFrame = require(modules.VerticallyScalingListFrame)

local HeightMapper = require(importer.HeightMapper)
local ImageSelector = require(importer.ImageSelector)

local CoreGui = game:GetService('CoreGui')
local StudioService = game:GetService("StudioService")
local UserInputService = game:GetService("UserInputService")
local ChangeHistoryService = game:GetService('ChangeHistoryService')

local ON_LIGHT  = "rbxasset://textures/TerrainTools/import_toggleOn.png"
local OFF_LIGHT = "rbxasset://textures/TerrainTools/import_toggleOff.png"
local ON_DARK   = "rbxasset://textures/TerrainTools/import_toggleOn_dark.png"
local OFF_DARK  = "rbxasset://textures/TerrainTools/import_toggleOff_dark.png"

local toggleOnImage = ON_LIGHT
local toggleOffImage = OFF_LIGHT

local supportedFileType = {"png"}
local useColorMap = false
local terrain 

local mouse = nil
local pluginGui	= nil
local screenGui = nil

local progressFrameObj = nil
local progressFrame = nil

local progressUpdate = nil
local heightMapper = nil

local MIN_STUDS = 5
local MAX_STUDS = 16384

local MIN_STUDS_ERROR_STR = string.format("Input must be greater than %d studs.", MIN_STUDS - 1)
local MAX_STUDS_ERROR_STR = string.format("Input can not exceed %d studs.", MAX_STUDS)
local INVALID_INPUT_ERROR = "Input is not a valid number."

local WARN_HEIGHTMAP_MISSING = "HeightMap required to begin importing Terrain"
local WARN_INVALID_POS_INPUT = "Position has invalid input"
local WARN_INVALID_SIZE_INPUT = "Size has invalid input."
local WARN_SIZE_REQUIRED = "Size of region must be defined."

-- these two targets are ImageSelectors that
-- hold the target files
local targetHeightMap = nil
local targetColorMap = nil

local regionPosition = nil
local regionSize = nil

-- for each of x, y, z
local posHasError = {false, false, false}
local sizeHasError = {false, false, false}

local terrainImporterFrame = nil
local generating = false

local SECOND_COLUMN_OFFSET = 90 + GuiUtilities.StandardLineLabelLeftMargin
local TEXTBOX_HEIGHT = 22
local LABEL_HEIGHT = 16

local SECTION_PADDING = 12
local PADDING = 4

local IMAGE_SELECT_FRAME_SIZE = UDim2.new(1, 0, 0, 60)

local function MakeTerrainImporterFrame()
	local verticallyScalingListFrameObj = VerticallyScalingListFrame.new("GenerationFrame")
	local verticallyScalingListFrame = verticallyScalingListFrameObj:GetFrame()

	local mapSettingsFrame = MakeMapSettingsFrame()
	mapSettingsFrame.Parent = verticallyScalingListFrame
	mapSettingsFrame.LayoutOrder = 1

	local materialSettingsFrame = MakeMaterialSettingsFrame()
	materialSettingsFrame.Parent = verticallyScalingListFrame
	materialSettingsFrame.LayoutOrder = 2

	local importButtonFrame = MakeButtonsFrame()
	importButtonFrame.Parent = verticallyScalingListFrame
	importButtonFrame.LayoutOrder = 3

	return verticallyScalingListFrame
end

function module:Setup(thePluginGui, contentFrame)
	terrain = workspace.Terrain
	pluginGui = thePluginGui
	
	screenGui = Instance.new("ScreenGui")
	screenGui.Name = "_TerrainImportGui"
	
	progressFrameObj = ProgressFrame.new()
	progressFrame = progressFrameObj:GetFrame()
	progressFrameObj:GetPauseButton().Visible = false
	progressFrameObj:GetCancelButton().Visible = false
	progressFrame.Parent = screenGui
	
	progressUpdate = Instance.new("BindableEvent")
	heightMapper = HeightMapper.new(progressUpdate)
	
	progressUpdate.Event:Connect(function (completionPercent)
		if completionPercent &lt; 1 then
			progressFrame.Visible = true
			progressFrameObj:GetFill().Size = UDim2.new(completionPercent, 0, 1, 0)
		else
			progressFrame.Visible = false
		end
	end)
	
	terrainImporterFrame = MakeTerrainImporterFrame()
	terrainImporterFrame.Parent = contentFrame

	terrainImporterFrame.ImportButton.ImportTerrainButton.MouseButton1Down:connect(importTerrain)
	
	return terrainImporterFrame
end

function MakeMapSettingsFrame()
	local mapSettingsObj = CollapsibleTitledSection.new('MapSettingsFrame',
		"Map Settings", -- need to localize
		true, -- show title
		true, -- minimizable
		false)-- init minimized

	local contentFrame = mapSettingsObj:GetContentsFrame()

	local hackPadding = Instance.new("Frame")
	hackPadding.BorderSizePixel = 0
	hackPadding.LayoutOrder = 1
	hackPadding.Parent = contentFrame

	local heightMapFrame = Instance.new("Frame")
	heightMapFrame.Size = IMAGE_SELECT_FRAME_SIZE
	heightMapFrame.BackgroundTransparency = 1
	heightMapFrame.LayoutOrder = 2
	heightMapFrame.Parent = contentFrame

	local heightMapLabel = GuiUtilities.MakeStandardPropertyLabel("Heightmap")
	heightMapLabel.TextYAlignment = Enum.TextYAlignment.Top
	heightMapLabel.Parent = heightMapFrame

	targetHeightMap = ImageSelector.new(supportedFileType)
	targetHeightMap:getFrame().Position = UDim2.new(0, SECOND_COLUMN_OFFSET, 0, 0)
	targetHeightMap:getFrame().Parent = heightMapFrame

	local initialFrameHeight = TEXTBOX_HEIGHT * 3 + PADDING * 2

	regionPosition = TabbableVector3Input.new("Position", {0, 0, 0})
	regionPosition:GetFrame().LayoutOrder = 3
	regionPosition:GetFrame().Parent = contentFrame

	regionPosition:SetWarningFunc(function (text, index)
		local num = tonumber(text)
		if num then
			posHasError[index] = false
			return true
		end
		posHasError[index] = true
		return false, INVALID_INPUT_ERROR
	end)

	regionSize = TabbableVector3Input.new("Size", {1024, 512, 1024})
	regionSize:GetFrame().LayoutOrder = 4
	regionSize:GetFrame().Parent = contentFrame


	-- these error messages should be localized when we submit changes for the final
	regionSize:SetWarningFunc(function (text, index)
		local num = tonumber(text)
		sizeHasError[index] = true
		if not num then
			return false, INVALID_INPUT_ERROR
		end

		if num &lt; MIN_STUDS then
			return false, MIN_STUDS_ERROR_STR
		end

		if num > MAX_STUDS then
			return false, MAX_STUDS_ERROR_STR
		end

		sizeHasError[index] = false
		return true
	end)

	--link the position and region so we can tab across them
	regionPosition:LinkToNextTabbableVector3Input(regionSize)
	regionSize:LinkToNextTabbableVector3Input(regionPosition)

	local hackPadding2 = Instance.new("Frame")
	hackPadding2.BorderSizePixel = 0
	hackPadding2.LayoutOrder = 5
	hackPadding2.Parent = contentFrame

	local sectionUIListLayout = Instance.new("UIListLayout")
	sectionUIListLayout.Padding = UDim.new(0, SECTION_PADDING)
	sectionUIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	sectionUIListLayout.FillDirection = Enum.FillDirection.Vertical
	sectionUIListLayout.Parent = contentFrame

	GuiUtilities.AdjustHeightDynamicallyToLayout(contentFrame, sectionUIListLayout)

	return mapSettingsObj:GetSectionFrame()
end

function MakeMaterialSettingsFrame()
	local materialFrameObj = CollapsibleTitledSection.new('MaterialSettings',
		"Material Settings", -- need localize
		true, -- show title
		true, -- minimizable
		false-- init minimized
	 )

	local materialFrame = materialFrameObj:GetContentsFrame()

	local hackPadding = Instance.new("Frame")
	hackPadding.BorderSizePixel = 0
	hackPadding.LayoutOrder = 1
	hackPadding.Parent = materialFrame

	local colorMatSliderFrame = Instance.new("Frame")
	colorMatSliderFrame.Size = UDim2.new(1, 0, 0, TEXTBOX_HEIGHT)
	colorMatSliderFrame.BackgroundTransparency = 1
	colorMatSliderFrame.LayoutOrder = 2
	colorMatSliderFrame.Parent = materialFrame

	local colorMapLabel = GuiUtilities.MakeStandardPropertyLabel("Use Colormap")
	colorMapLabel.TextYAlignment = Enum.TextYAlignment.Top
	colorMapLabel.AnchorPoint = Vector2.new(0, 0)
	colorMapLabel.Parent = colorMatSliderFrame

	local initTheme = settings().Studio["UI Theme"]
	toggleOffImage = initTheme == Enum.UITheme.Dark and OFF_DARK or OFF_LIGHT
	toggleOnImage = initTheme == Enum.UITheme.Dark and ON_DARK or ON_LIGHT

	local toggleButton = Instance.new("ImageButton")
	toggleButton.Size = UDim2.new(0, 27, 0, LABEL_HEIGHT)
	toggleButton.Position = UDim2.new(0, SECOND_COLUMN_OFFSET, 1, -LABEL_HEIGHT)
	toggleButton.Image = toggleOffImage
	toggleButton.BackgroundTransparency = 1
	toggleButton.Parent = colorMatSliderFrame

	-- button Toggle
	toggleButton.Activated:connect(function ()
		useColorMap = not useColorMap
		if useColorMap then
			toggleButton.Image = toggleOnImage
		else
			toggleButton.Image = toggleOffImage
		end
	end)

	settings().Studio.ThemeChanged:connect(function ()
		if settings().Studio["UI Theme"] == Enum.UITheme.Dark then
			toggleOffImage = OFF_DARK
			toggleOnImage = ON_DARK
		else -- we could check for light but since it's the fall back no need
			toggleOffImage = OFF_LIGHT
			toggleOnImage = ON_LIGHT
		end

		toggleButton.Image = useColorMap and toggleOnImage or toggleOffImage
	end)

	local colorMatFrame = Instance.new("Frame")
	colorMatFrame.Size = IMAGE_SELECT_FRAME_SIZE
	colorMatFrame.BackgroundTransparency = 1
	colorMatFrame.LayoutOrder = 3
	colorMatFrame.Parent = materialFrame

	targetColorMap = ImageSelector.new(supportedFileType)
	targetColorMap:getFrame().Position = UDim2.new(0, SECOND_COLUMN_OFFSET, 0, 0)
	targetColorMap:getFrame().Parent = colorMatFrame

	targetColorMap:setImageSelectedCallback(function ()
		useColorMap = true
		toggleButton.Image = toggleOnImage
	end)

	local hackPadding2 = Instance.new("Frame")
	hackPadding2.BorderSizePixel = 0
	hackPadding2.LayoutOrder = 4
	hackPadding2.Parent = materialFrame

	local sectionUIListLayout = Instance.new("UIListLayout")
	sectionUIListLayout.Padding = UDim.new(0, 8)
	sectionUIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	sectionUIListLayout.FillDirection = Enum.FillDirection.Vertical
	sectionUIListLayout.Parent = materialFrame

	GuiUtilities.AdjustHeightDynamicallyToLayout(materialFrame, sectionUIListLayout)

	return materialFrameObj:GetSectionFrame()
end

function MakeButtonsFrame()
	local frame = GuiUtilities.MakeFixedHeightFrame("ImportButton", GuiUtilities.kBottomButtonsFrameHeight)
	frame.BackgroundTransparency = 1

	local importButtonObj = CustomTextButton.new("ImportTerrainButton", "Import")
	local importButton = importButtonObj:getButton()

	importButton.Size = UDim2.new(.7, 0, 0, GuiUtilities.kBottomButtonsHeight)
	importButton.Position = UDim2.new(.15, 0, 1, -GuiUtilities.kBottomButtonsHeight)
	importButton.Parent = frame

	return frame
end

function importTerrain()
	if targetHeightMap and not targetHeightMap:imageSelected() then
		warn(WARN_HEIGHTMAP_MISSING)
		return
	end
	
	if posHasError[1] or posHasError[2] or posHasError[3] then
		warn(WARN_INVALID_POS_INPUT)
		return
	end

	if sizeHasError[1] or sizeHasError[2] or sizeHasError[3] then
		warn(WARN_INVALID_SIZE_INPUT)
		return
	end

	terrain = workspace.Terrain
	
	if not generating then
		generating = true

		local size = regionSize:GetVector3()
		local center = regionPosition:GetVector3() or Vector3.new(0, 0, 0)
		local region
		
		if size then
			-- expect Studs
			local offset = size / 2
			local regionStart = (center - offset)
			local regionEnd = (center + offset)
			region = Region3.new(regionStart, regionEnd)
			region = region:ExpandToGrid(4)

			local heightMap = targetHeightMap:getPngFile()
			local colorMap = nil
			
			if useColorMap and targetColorMap and targetColorMap:imageSelected() then
				colorMap = targetColorMap:getPngFile()
			end
			
			heightMapper:Import(region, heightMap, colorMap)
		else
			warn(WARN_SIZE_REQUIRED)
		end

		generating = false
	end
end

function module:SetEnabled(enabled)
	terrainImporterFrame.Visible = enabled
	screenGui.Parent = enabled and CoreGui or nil
end

return module</string>
        </Properties>
      </Item>
      <Item class="Script" referent="31">
        <Properties>
          <string name="Name">main</string>
          <string name="Source">------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @ CloneTrooper1019, 2019
-- main.server.lua
------------------------------------------------------------------------------------------------------------------------------------------------------------
-- This is the main script for this fork of the terrain importer.
-- It mounts the importer widget into a PluginGui with a button to toggle it.
------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Setup
------------------------------------------------------------------------------------------------------------------------------------------------------------

local project = script.Parent
local terrainImporter = require(project.TerrainImporter)

local toolbar = plugin:CreateToolbar("Terrain")
local importButton = toolbar:CreateButton(
	"Import Terrain",
	"Create terrain heightmaps using PNG files!",
	"rbxasset://textures/TerrainTools/mt_terrain_import.png"
)

local dockWidgetInfo = DockWidgetPluginGuiInfo.new(Enum.InitialDockState.Right, false, false, 0, 0, 289)

local pluginGui = plugin:CreateDockWidgetPluginGui("TerrainImporter", dockWidgetInfo)
pluginGui.Title = "Terrain Importer"
pluginGui.Name = pluginGui.Title

local content = Instance.new("ScrollingFrame")
content.BorderSizePixel = 0
content.ScrollBarThickness = 17
content.Size = UDim2.new(1, 0, 1, 0)
content.CanvasSize = UDim2.new(1, 0, 0, 466)
content.ElasticBehavior = Enum.ElasticBehavior.Never
content.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar
content.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
content.MidImage = "rbxasset://textures/TerrainTools/EdgesSquare17x1.png"
content.TopImage = "rbxasset://textures/TerrainTools/UpArrowButtonOpen17.png"
content.BottomImage = "rbxasset://textures/TerrainTools/DownArrowButtonOpen17.png"
content.Parent = pluginGui

terrainImporter:Setup(pluginGui, content)

------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Update Listeners
------------------------------------------------------------------------------------------------------------------------------------------------------------

local Studio = settings():GetService("Studio")
local enabledChanged = pluginGui:GetPropertyChangedSignal("Enabled")

local function onThemeChanged()
	local theme = Studio.Theme
	content.BackgroundColor3 = theme:GetColor("MainBackground")
end

local function onEnabledChanged()
	local enabled = pluginGui.Enabled
	terrainImporter:SetEnabled(enabled)
	importButton:SetActive(enabled)
end

local function onClicked()
	pluginGui.Enabled = not pluginGui.Enabled
end

onThemeChanged()
Studio.ThemeChanged:Connect(onThemeChanged)

onEnabledChanged()
enabledChanged:Connect(onEnabledChanged)

importButton.Click:Connect(onClicked)

------------------------------------------------------------------------------------------------------------------------------------------------------------</string>
        </Properties>
      </Item>
    </Item>
  </Item>
</roblox>